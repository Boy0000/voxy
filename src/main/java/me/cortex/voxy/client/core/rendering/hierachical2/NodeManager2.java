package me.cortex.voxy.client.core.rendering.hierachical2;

import it.unimi.dsi.fastutil.ints.IntArrayList;
import it.unimi.dsi.fastutil.ints.IntOpenHashSet;
import it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap;
import me.cortex.voxy.client.core.gl.GlBuffer;
import me.cortex.voxy.client.core.rendering.building.BuiltSection;
import me.cortex.voxy.client.core.rendering.building.SectionUpdateRouter;
import me.cortex.voxy.client.core.rendering.section.AbstractSectionGeometryManager;
import me.cortex.voxy.client.core.rendering.util.UploadStream;
import me.cortex.voxy.client.core.util.ExpandingObjectAllocationList;
import me.cortex.voxy.common.Logger;
import me.cortex.voxy.common.world.WorldEngine;
import me.cortex.voxy.commonImpl.VoxyCommon;
import net.caffeinemc.mods.sodium.client.util.MathUtil;

import java.util.List;



//TODO FIXME: CIRTICAL ISSUE: if a node is a top level section and is empty, when a child is tried to be made it explodes
// since all the children are empty
//  To properly fix this, the top level nodes should only exist if there are non empty children
// (issues related to this fix, lod updates from 0 children state to something children state, aswell as other way round)


public class NodeManager2 {
    private static final boolean VERIFY_NODE_MANAGER_OPERATIONS = VoxyCommon.isVerificationFlagOn("nodeManager");
    //Assumptions:
    // all nodes have children (i.e. all nodes have at least one child existence bit set at all times)
    // leaf nodes always contain geometry (empty geometry counts as geometry (it just doesnt take any memory to store))
    // All nodes except top nodes have parents

    //NOTE:
    // For the queue processing, will need a redirect node-value type
    //      since for inner node child resize gpu could take N frames to update



    //There is a very funny issue that has kinda, just resolved itself accidentally,
    // however i wonder if i want a better solution for.
    //That issue is, top level nodes that have no children
    // the accidental solution, is that when the node is marked, it generates
    // the child request,
    // however, since there are no children in it, it sticks around, since there isnt anything to update it and invoke
    // the finishRequest on it
    // if the top level node ends up being updated with a child update, it should automatically solve itself
    // as the new children are added to the already inprogress request!!!!

    public static final int NULL_GEOMETRY_ID = -1;
    public static final int EMPTY_GEOMETRY_ID = -2;

    public static final int NODE_ID_MSK = ((1<<24)-1);
    private static final int NODE_TYPE_MSK = 0b11<<30;
    private static final int NODE_TYPE_LEAF = 0b00<<30;
    private static final int NODE_TYPE_INNER = 0b01<<30;
    private static final int NODE_TYPE_REQUEST = 0b10<<30;

    private static final int REQUEST_TYPE_SINGLE = 0b0<<29;
    private static final int REQUEST_TYPE_CHILD = 0b1<<29;
    private static final int REQUEST_TYPE_MSK = 0b1<<29;

    //Single requests are basically _only_ generated by the insertion of top level nodes
    private final ExpandingObjectAllocationList<SingleNodeRequest> singleRequests = new ExpandingObjectAllocationList<>(SingleNodeRequest[]::new);
    private final ExpandingObjectAllocationList<NodeChildRequest> childRequests = new ExpandingObjectAllocationList<>(NodeChildRequest[]::new);
    private final IntOpenHashSet nodeUpdates = new IntOpenHashSet();
    private final AbstractSectionGeometryManager geometryManager;
    private final SectionUpdateRouter updateRouter;
    private final Long2IntOpenHashMap activeSectionMap = new Long2IntOpenHashMap();
    private final NodeStore nodeData;
    public final int maxNodeCount;
    private final IntArrayList topLevelNodeIds = new IntArrayList();
    private int activeNodeRequestCount;

    public NodeManager2(int maxNodeCount, AbstractSectionGeometryManager geometryManager, SectionUpdateRouter updateRouter) {
        if (!MathUtil.isPowerOfTwo(maxNodeCount)) {
            throw new IllegalArgumentException("Max node count must be a power of 2");
        }
        if (maxNodeCount>(1<<24)) {
            throw new IllegalArgumentException("Max node count cannot exceed 2^24");
        }
        this.activeSectionMap.defaultReturnValue(-1);
        this.updateRouter = updateRouter;
        this.maxNodeCount = maxNodeCount;
        this.nodeData = new NodeStore(maxNodeCount);
        this.geometryManager = geometryManager;
    }

    public void insertTopLevelNode(long pos) {
        if (this.activeSectionMap.containsKey(pos)) {
            Logger.error("Tried inserting top level pos " + WorldEngine.pprintPos(pos) + " but it was in active map, discarding!");
            return;
        }

        var request = new SingleNodeRequest(pos);
        int id = this.singleRequests.put(request);
        this.updateRouter.watch(pos, WorldEngine.UPDATE_FLAGS);
        this.activeSectionMap.put(pos, id|NODE_TYPE_REQUEST|REQUEST_TYPE_SINGLE);
    }

    public void removeTopLevelNode(long pos) {
        int nodeId = this.activeSectionMap.get(pos);
        if (nodeId == -1) {
            Logger.error("Tried removing top level pos " + WorldEngine.pprintPos(pos) + " but it was not in active map, discarding!");
            return;
        }
        //TODO: assert is top level node

        //TODO:FIXME augment topLevelNodeIds with a hashmap from node id to array index
        // OR!! just ensure the list is always ordered?? maybe? idk i think hashmap is best
        // since the array list might get shuffled as nodes are removed
        // since need to move the entry at the end of the array to fill a hole made
    }


    IntArrayList getTopLevelNodeIds() {
        return this.topLevelNodeIds;
    }

    //==================================================================================================================

    public void processGeometryResult(BuiltSection sectionResult) {
        long pos = sectionResult.position;
        int nodeId = this.activeSectionMap.get(pos);
        if (nodeId == -1) {
            Logger.error("Got geometry update for pos " + WorldEngine.pprintPos(pos) + " but it was not in active map, discarding!");
            sectionResult.free();
            return;
        }

        if ((nodeId&NODE_TYPE_MSK)==NODE_TYPE_REQUEST) {
            //For a request
            if ((nodeId&REQUEST_TYPE_MSK)==REQUEST_TYPE_SINGLE) {
                var request = this.singleRequests.get(nodeId&NODE_ID_MSK);
                request.setMesh(this.uploadReplaceSection(request.getMesh(), sectionResult));

                //sectionResult has a cheeky childExistence field that we can use to set the request too, this is just
                // because processChildChange is only ever invoked when child existence changes, so we still need to
                // populate the request somehow, it will only set it if it hasnt been set before
                if (!request.hasChildExistenceSet()) {
                    request.setChildExistence(sectionResult.childExistence);
                }

                if (request.isSatisfied()) {
                    this.singleRequests.release(nodeId&NODE_ID_MSK);
                    this.finishRequest(request);
                }
            } else if ((nodeId&REQUEST_TYPE_MSK)==REQUEST_TYPE_CHILD) {
                var request = this.childRequests.get(nodeId&NODE_ID_MSK);
                int childId = getChildIdx(pos);
                request.setChildMesh(childId, this.uploadReplaceSection(request.getChildMesh(childId), sectionResult));
                if (!request.hasChildChildExistence(childId)) {
                    request.setChildChildExistence(childId, sectionResult.childExistence);
                }

                if (request.isSatisfied()) {
                    this.finishRequest(nodeId&NODE_ID_MSK, request);
                }
            } else {
                throw new IllegalStateException();
            }
        } else if ((nodeId&NODE_TYPE_MSK)==NODE_TYPE_INNER || (nodeId&NODE_TYPE_MSK)==NODE_TYPE_LEAF) {
            /*
            //More verification
            if (sectionResult.childExistence != this.nodeData.getNodeChildExistence(nodeId)) {
                Logger.error("Child existance verification mismatch. expected: " +  this.nodeData.getNodeChildExistence(nodeId) + " got: " + sectionResult.childExistence);
                if (this.nodeData.isNodeRequestInFlight(nodeId)) {
                    Logger.error("AAAAAAAAAA");
                }
            }*/

            // Just doing a geometry update
            if (this.updateNodeGeometry(nodeId&NODE_ID_MSK, sectionResult) != 0) {
                this.invalidateNode(nodeId&NODE_ID_MSK);
            }
        }
    }

    private int uploadReplaceSection(int meshId, BuiltSection section) {
        if (section.isEmpty()) {
            if (meshId != NULL_GEOMETRY_ID && meshId != EMPTY_GEOMETRY_ID) {
                this.geometryManager.removeSection(meshId);
            }
            section.free();
            return EMPTY_GEOMETRY_ID;
        }
        if (meshId != NULL_GEOMETRY_ID && meshId != EMPTY_GEOMETRY_ID) {
            return this.geometryManager.uploadReplaceSection(meshId, section);
        }
        return this.geometryManager.uploadSection(section);
    }

    private int updateNodeGeometry(int node, BuiltSection geometry) {
        int previousGeometry = this.nodeData.getNodeGeometry(node);
        int newGeometry = EMPTY_GEOMETRY_ID;
        if (previousGeometry != EMPTY_GEOMETRY_ID && previousGeometry != NULL_GEOMETRY_ID) {
            if (!geometry.isEmpty()) {
                newGeometry = this.geometryManager.uploadReplaceSection(previousGeometry, geometry);
            } else {
                this.geometryManager.removeSection(previousGeometry);
            }
        } else {
            if (!geometry.isEmpty()) {
                newGeometry = this.geometryManager.uploadSection(geometry);
            }
        }

        if (previousGeometry != newGeometry) {
            this.nodeData.setNodeGeometry(node, newGeometry);
        }
        if (previousGeometry == newGeometry) {
            return 0;//No change
        } else if (previousGeometry == EMPTY_GEOMETRY_ID || previousGeometry == NULL_GEOMETRY_ID) {
            return 1;//Became non-empty/non-null
        } else {
            return 2;//Became empty
        }
    }
    //==================================================================================================================

    //TODO: cleanup this code shitshow and extract common operations to reduce code duplication
    public void processChildChange(long pos, byte childExistence) {
        int nodeId = this.activeSectionMap.get(pos);
        if (nodeId == -1) {
            Logger.error("Got child change for pos " + WorldEngine.pprintPos(pos) + " but it was not in active map, ignoring!");
            return;
        }


        if ((nodeId&NODE_TYPE_MSK)==NODE_TYPE_REQUEST) {
            //For a request
            if ((nodeId&REQUEST_TYPE_MSK)==REQUEST_TYPE_SINGLE) {
                var request = this.singleRequests.get(nodeId&NODE_ID_MSK);
                request.setChildExistence(childExistence);
                if (request.isSatisfied()) {
                    this.singleRequests.release(nodeId&NODE_ID_MSK);
                    this.finishRequest(request);
                }
            } else if ((nodeId&REQUEST_TYPE_MSK)==REQUEST_TYPE_CHILD) {
                var request = this.childRequests.get(nodeId&NODE_ID_MSK);
                request.setChildChildExistence(getChildIdx(pos), childExistence);
                if (request.isSatisfied()) {
                    this.finishRequest(nodeId&NODE_ID_MSK, request);
                }
            } else {
                throw new IllegalStateException();
            }
        } else if ((nodeId&NODE_TYPE_MSK)==NODE_TYPE_INNER) {
            this.updateChildSectionsInner(pos, nodeId&NODE_ID_MSK, childExistence);
        } else if ((nodeId&NODE_TYPE_MSK)==NODE_TYPE_LEAF) {

            //We might be leaf but we still might be inflight
            if (this.nodeData.isNodeRequestInFlight(nodeId&NODE_ID_MSK)) {
                //  Logger.error("UNFINISHED OPERATION TODO: FIXME: painful operation, needs to account for both adding and removing, need to do the same with inner node, but also create requests, or cleanup children");
                int requestId = this.nodeData.getNodeRequest(nodeId);
                var request = this.childRequests.get(requestId);// TODO: do not assume request is childRequest (it will probably always be)
                if (request.getPosition() != pos) throw new IllegalStateException("Request is not at pos");
                {//Update the request
                    byte oldMsk = request.getMsk();
                    byte change = (byte) (oldMsk ^ childExistence);
                    {//Remove children and free/release associated meshes
                        byte rem = (byte) (change&oldMsk);
                        for (int i = 0; i < 8; i++) {
                            if ((rem&(1<<i))==0) continue;
                            int meshId = request.removeAndUnRequire(i);
                            if (meshId != NULL_GEOMETRY_ID && meshId != EMPTY_GEOMETRY_ID) {
                                this.geometryManager.removeSection(meshId);
                            }

                            //Remove child from being watched and activeSections
                            long cPos = makeChildPos(pos, i);
                            if (this.activeSectionMap.remove(cPos) == -1) {//TODO: verify the removed section is a request type of child and the request id matches this
                                throw new IllegalStateException("Child pos was in a request but not in active section map");
                            }
                            if (!this.updateRouter.unwatch(cPos, WorldEngine.UPDATE_FLAGS)) {
                                throw new IllegalStateException("Child pos was not being watched");
                            }
                        }
                    }

                    {//Add new children to the request
                        byte rem = (byte) (change&childExistence);
                        for (int i = 0; i < 8; i++) {
                            if ((rem&(1<<i))==0) continue;
                            //Add child to request
                            request.addChildRequirement(i);

                            //Add child to active tracker and put in updateRouter
                            long cPos = makeChildPos(pos, i);
                            if (this.activeSectionMap.put(cPos, requestId|NODE_TYPE_REQUEST|REQUEST_TYPE_CHILD) != -1) {
                                throw new IllegalStateException("Child pos was already in active section tracker but was part of a request");
                            }
                            if (!this.updateRouter.watch(cPos, WorldEngine.UPDATE_FLAGS)) {
                                throw new IllegalStateException("Child pos update router issue");
                            }
                        }
                    }

                    //If the request is now satisfied we need to finish it
                    if (request.isSatisfied()) {
                        this.finishRequest(requestId, request);
                    }
                }
            }

            //Just need to update the child node data, nothing else
            this.nodeData.setNodeChildExistence(nodeId&NODE_ID_MSK, childExistence);
            //Need to resubmit to gpu
            this.invalidateNode(nodeId&NODE_ID_MSK);//TODO:FIXME: Do we???
        }
    }

    private void updateChildSectionsInner(long pos, int nodeId, byte childExistence) {
        //Very complex and painful operation


        //TODO: operation of needing to create a request node to add new sections
        // (or modify the node to remove a child node (recursively probably ;-;))


        //This works in 2 parts, adding and removing, adding is (surprisingly) much easier than removing
        // adding, either adds to a request, or creates a new request
        byte existence = this.nodeData.getNodeChildExistence(nodeId);
        byte add = (byte) ((existence^childExistence)&childExistence);
        if (add != 0) {//We have nodes to add
            if (!this.nodeData.isNodeRequestInFlight(nodeId)) {//If there is not an existing request, create it
                var request = new NodeChildRequest(pos);
                int requestId = this.childRequests.put(request);

                this.nodeData.markRequestInFlight(nodeId);
                this.nodeData.setNodeRequest(nodeId, requestId);
                this.activeNodeRequestCount++;
            }
            //It is guaranteed that at this point the node has a request
            // so add the new nodes to it
            int requestId = this.nodeData.getNodeRequest(nodeId);
            var request = this.childRequests.get(requestId);// TODO: do not assume request is childRequest (it will probably always be)
            if (request.getPosition() != pos) throw new IllegalStateException("Request is not at pos");

            //Add all new children to the request
            for (int i = 0; i < 8; i++) {
                if ((add&(1<<i))==0) continue;
                //Add child to request
                request.addChildRequirement(i);
                //Add child to active tracker and put in updateRouter
                long cPos = makeChildPos(pos, i);
                if (this.activeSectionMap.put(cPos, requestId|NODE_TYPE_REQUEST|REQUEST_TYPE_CHILD) != -1) {
                    throw new IllegalStateException("Child pos was already in active section tracker but was part of a request");
                }
                if (!this.updateRouter.watch(cPos, WorldEngine.UPDATE_FLAGS)) {
                    throw new IllegalStateException("Child pos update router issue");
                }
            }
        }

        //Update the nodes existence msk to the new one
        // this needs to be before the removal since that may invoke requestFinish, which expects updated node masks
        //TODO: verify this
        this.nodeData.setNodeChildExistence(nodeId&NODE_ID_MSK, childExistence);

        // Do removals
        byte rem = (byte) ((existence^childExistence)&existence);
        if (rem != 0) {
            //If there is an inflight request, update it w.r.t removals
            if (this.nodeData.isNodeRequestInFlight(nodeId)) {
                int requestId = this.nodeData.getNodeRequest(nodeId);
                var request = this.childRequests.get(requestId);// TODO: do not assume request is childRequest (it will probably always be)
                if (request.getPosition() != pos) throw new IllegalStateException("Request is not at pos");


                byte reqRem = (byte) (request.getMsk()&rem);
                if (reqRem != 0) {
                    //There are things in the request to remove
                    for (int i = 0; i < 8; i++) {
                        if ((reqRem & (1 << i)) == 0) continue;
                        int meshId = request.removeAndUnRequire(i);
                        if (meshId != NULL_GEOMETRY_ID && meshId != EMPTY_GEOMETRY_ID) {
                            this.geometryManager.removeSection(meshId);
                        }

                        //Remove child from being watched and activeSections
                        long cPos = makeChildPos(pos, i);
                        if (this.activeSectionMap.remove(cPos) == -1) {//TODO: verify the removed section is a request type of child and the request id matches this
                            throw new IllegalStateException("Child pos was in a request but not in active section map");
                        }
                        if (!this.updateRouter.unwatch(cPos, WorldEngine.UPDATE_FLAGS)) {
                            throw new IllegalStateException("Child pos was not being watched");
                        }
                    }
                }
                rem ^= reqRem;
                //If the request is satisfied, submit the result
                if (request.isSatisfied()) {
                    this.finishRequest(requestId, request);
                }
            }

            if (rem != 0) {
                //There are child node entries that need removing
                Logger.error("UNFINISHED OPERATION TODO: FIXME");
            }
        }
    }

    //==================================================================================================================

    private void finishRequest(SingleNodeRequest request) {
        int id = this.nodeData.allocate();
        this.nodeData.setNodePosition(id, request.getPosition());
        this.nodeData.setNodeGeometry(id, request.getMesh());
        this.nodeData.setNodeChildExistence(id, request.getChildExistence());
        //TODO: this (or remove)
        //this.nodeData.setNodeType();
        this.activeSectionMap.put(request.getPosition(), id|NODE_TYPE_LEAF);//Assume that the result of any single request type is a leaf node
        this.invalidateNode(id);


        //Assume that this is always a top node
        // FIXME: DONT DO THIS
        this.topLevelNodeIds.add(id);
    }

    private void finishRequest(int requestId, NodeChildRequest request) {
        int parentNodeId = this.activeSectionMap.get(request.getPosition());
        if (parentNodeId == -1 || (parentNodeId&NODE_TYPE_MSK)==NODE_TYPE_REQUEST) {
            throw new IllegalStateException("CRITICAL BAD STATE!!! finishRequest tried to finish for a node that no longer exists in the map or has become a request type somehow?!!?!!" + WorldEngine.pprintPos(request.getPosition()) + " " + parentNodeId);
        }
        int parentNodeType = parentNodeId&NODE_TYPE_MSK;
        parentNodeId &= NODE_ID_MSK;

        if (parentNodeType==NODE_TYPE_LEAF) {
            int msk = Byte.toUnsignedInt(request.getMsk());
            int base = this.nodeData.allocate(Integer.bitCount(msk));
            int offset = -1;
            for (int childIdx = 0; childIdx < 8; childIdx++) {
                if ((msk&(1<<childIdx)) == 0) {
                    continue;
                }
                offset++;

                long childPos = makeChildPos(request.getPosition(), childIdx);
                int childNodeId = base+offset;
                //Fill in node
                this.nodeData.setNodePosition(childNodeId, childPos);
                byte childExistence = request.getChildChildExistence(childIdx);
                if (childExistence == 0) {
                    throw new IllegalStateException("Request result with child existence of 0");
                }
                this.nodeData.setNodeChildExistence(childNodeId, childExistence);
                this.nodeData.setNodeGeometry(childNodeId, request.getChildMesh(childIdx));
                //Mark for update
                this.invalidateNode(childNodeId);
                //Put in map
                int pid = this.activeSectionMap.put(childPos, childNodeId|NODE_TYPE_LEAF);
                if ((pid&NODE_TYPE_MSK) != NODE_TYPE_REQUEST) {
                    throw new IllegalStateException("Put node in map from request but type was not request: " + pid + " " + WorldEngine.pprintPos(childPos));
                }
            }
            //Free request
            this.childRequests.release(requestId);
            //Update the parent
            this.nodeData.setChildPtr(parentNodeId, base);
            this.nodeData.setChildPtrCount(parentNodeId, offset+1);
            this.nodeData.setNodeRequest(parentNodeId, 0);//TODO: create a better null request
            this.activeNodeRequestCount--;
            this.nodeData.unmarkRequestInFlight(parentNodeId);

            //Change it from a leaf to an inner node
            {
                int pid = this.activeSectionMap.remove(request.getPosition());
                if (pid == -1 || (pid & NODE_TYPE_MSK) != NODE_TYPE_LEAF) {
                    throw new IllegalStateException("Unexpected node mapping: " + pid);
                }
            }
            //_this is why it hasnt been working, grrr, wasnt doing this_
            this.activeSectionMap.put(request.getPosition(), NODE_TYPE_INNER|parentNodeId);//Set the type from leaf to inner node

            this.invalidateNode(parentNodeId);
        } else if (parentNodeType==NODE_TYPE_INNER) {
            //Logger.error("TODO: FIXME FINISH: finishRequest NODE_TYPE_INNER");
            //For this, only need to add the nodes to the existing child set thing (shuffle around whatever) dont ever have to remove nodes

            int childPtr = this.nodeData.getChildPtr(parentNodeId);
            int childCnt = this.nodeData.getChildPtrCount(parentNodeId);
            if (childPtr == -1) {
                throw new IllegalStateException();
            }

            //Ok so technically, it _is ok_ to just add to the end of the childPtr, however, imo that is stupid
            // and it should follow the logical allocation with respect to the 8 child indices
            // this means, need to extract the child indices already in the ptr (or technically could use the child existance? but having both and doing verification would be good)

            int existingChildMsk = 0;
            for (int i = 0; i < childCnt; i++) {
                if (!this.nodeData.nodeExists(i+childPtr)) {
                    throw new IllegalStateException();
                }
                existingChildMsk |= 1<<getChildIdx(this.nodeData.nodePosition(i+childPtr));
            }
            int reqMsk = Byte.toUnsignedInt(request.getMsk());
            if ((byte) (existingChildMsk|reqMsk) != this.nodeData.getNodeChildExistence(parentNodeId)) {
                //System.out.println(Integer.toBinaryString(Byte.toUnsignedInt(this.nodeData.getNodeChildExistence(parentNodeId))));System.out.println(Integer.toBinaryString(existingChildMsk));System.out.println(Integer.toBinaryString(reqMsk));
                throw new IllegalStateException("node data existence state does not match pointer mask");
            }


            if ((reqMsk&existingChildMsk)!=0) {
                throw new IllegalStateException("Overlapping child data!!! BAD");
            }

            //Create the new allocation
            int newMsk = reqMsk | existingChildMsk;
            int newChildPtr = this.nodeData.allocate(Integer.bitCount(newMsk));

            //Need to interlace the old and new data into the new allocation
            // FOR OLD ALLOCATIONS, NEED TO UPDATE POINTERS
            int childId = newChildPtr-1;
            int prevChildId = childPtr-1;
            for (int i = 0; i < 8; i++) {
                if ((newMsk&(1<<i))==0) continue;
                childId++;

                if ((reqMsk&(1<<i))!=0) {
                    //Its an entry from the request
                    long childPos = makeChildPos(request.getPosition(), i);

                    this.nodeData.setNodePosition(childId, childPos);
                    byte childExistence = request.getChildChildExistence(i);
                    if (childExistence == 0) {
                        throw new IllegalStateException("Request result with child existence of 0");
                    }
                    this.nodeData.setNodeChildExistence(childId, childExistence);
                    this.nodeData.setNodeGeometry(childId, request.getChildMesh(i));

                    //Mark for update
                    this.invalidateNode(childId);

                    //Put in map
                    int pid = this.activeSectionMap.put(childPos, childId|NODE_TYPE_LEAF);
                    if ((pid&NODE_TYPE_MSK) != NODE_TYPE_REQUEST) {
                        throw new IllegalStateException("Put node in map from request but type was not request: " + pid + " " + WorldEngine.pprintPos(childPos));
                    }
                } else {
                    prevChildId++;

                    long pos = this.nodeData.nodePosition(prevChildId);

                    //Its a previous entry, copy it to its new location
                    this.nodeData.copyNode(prevChildId, childId);

                    int prevNodeId = this.activeSectionMap.get(pos);
                    if ((prevNodeId&NODE_TYPE_MSK) == NODE_TYPE_REQUEST) {
                        throw new IllegalStateException();
                    }
                    if ((prevNodeId&NODE_ID_MSK) != prevChildId) {
                        throw new IllegalStateException("State inconsistency");
                    }
                    this.activeSectionMap.put(pos, (prevNodeId&NODE_TYPE_MSK)|childId);
                    //Need to invalidate the old and the new
                    this.invalidateNode(prevChildId);
                    this.invalidateNode(childId);
                }
            }

            //Do final steps

            //Free the old child data
            this.nodeData.free(childPtr, childCnt);

            //Free request
            this.childRequests.release(requestId);

            //Update the parent
            this.nodeData.setChildPtr(parentNodeId, newChildPtr);
            this.nodeData.setChildPtrCount(parentNodeId, Integer.bitCount(newMsk));
            this.nodeData.setNodeRequest(parentNodeId, 0);//TODO: create a better null request
            this.activeNodeRequestCount--;
            this.nodeData.unmarkRequestInFlight(parentNodeId);

            //Invalidate parent
            this.invalidateNode(parentNodeId);
        } else {
            throw new IllegalStateException();
        }
    }

    //==================================================================================================================
    public void processRequest(long pos) {
        int nodeId = this.activeSectionMap.get(pos);
        if (nodeId == -1) {
            Logger.error("Got request for pos " + WorldEngine.pprintPos(pos) + " but it was not in active map, ignoring!");
            return;
        }
        int nodeType = nodeId&NODE_TYPE_MSK;
        nodeId &= NODE_ID_MSK;
        if (nodeType == NODE_TYPE_REQUEST) {
            Logger.error("Tried processing request for pos: " + WorldEngine.pprintPos(pos) + " but its type was a request, ignoring!");
            return;
        } else if (nodeType != NODE_TYPE_LEAF && nodeType != NODE_TYPE_INNER ) {
            throw new IllegalStateException("Unknown node type: " + nodeType);
        }

        if (this.nodeData.isNodeRequestInFlight(nodeId)) {
            Logger.warn("Tried processing a node that already has a request in flight: " + nodeId + " pos: " + WorldEngine.pprintPos(pos) + " ignoring");
            return;
        }


        //TODO: ADJUST AND FIX THIS TO MAKE IT REMOVE THE LAST THING IN QUEUE OR SOMETHING
        //if (this.activeNodeRequestCount > 100 && WorldEngine.getLevel(pos) < 2) {
            //Logger.info("Many active requests, declining request at " + WorldEngine.pprintPos(pos));
        //    this.invalidateNode(nodeId);
        //    return;
        //}


        this.nodeData.markRequestInFlight(nodeId);
        if (nodeType == NODE_TYPE_LEAF) {
            //The hard one of processRequest, spin up a new request for the node
            this.makeLeafChildRequest(nodeId);

        } else {//nodeType == NODE_TYPE_INNER
            //TODO: assert that the node isnt already being watched for geometry, if it is, just spit out a warning? and ignore
            Logger.error("TODO FINISH THIS");
            if (!this.updateRouter.watch(pos, WorldEngine.UPDATE_TYPE_BLOCK_BIT)) {
                //FIXME: i think this can occur accidently? when removing nodes or something creating leaf nodes
                // or other, the node might be wanted to be watched by gpu, but cpu already started watching it a few frames ago
                Logger.warn("Node: " + nodeId + " at pos: " + WorldEngine.pprintPos(pos) + " got update request, but geometry was already being watched");
            }
        }
    }

    private void makeLeafChildRequest(int nodeId) {
        long pos = this.nodeData.nodePosition(nodeId);
        byte childExistence = this.nodeData.getNodeChildExistence(nodeId);

        //Enqueue a leaf expansion request
        var request = new NodeChildRequest(pos);
        int requestId = this.childRequests.put(request);

        //Only request against the childExistence mask, since the guarantee is that if childExistence bit is not set then that child is guaranteed to be empty
        for (int i = 0; i < 8; i++) {
            if ((childExistence&(1<<i))==0) {
                //Dont watch or enqueue the child node cause it doesnt exist
                continue;
            }
            long childPos = makeChildPos(pos, i);
            request.addChildRequirement(i);

            //Insert all the children into the tracking map with the node id
            int pid = this.activeSectionMap.put(childPos, requestId|NODE_TYPE_REQUEST|REQUEST_TYPE_CHILD);

            if (pid != -1) {
                String extra = "";
                if ((pid&NODE_TYPE_MSK)==NODE_TYPE_LEAF) {
                    extra = " type leaf: pos " + WorldEngine.pprintPos( this.nodeData.nodePosition(pid)) + " hasRequest: " + this.nodeData.isNodeRequestInFlight(pid);
                }
                throw new IllegalStateException("Leaf request creation failed to insert child into map as a mapping already existed for the node! pos: " + WorldEngine.pprintPos(childPos) + " id: " + pid + " for parent " + WorldEngine.pprintPos(pos) + " extra " + extra);
            }

            //Watch and request the child node at the given position
            if (!this.updateRouter.watch(childPos, WorldEngine.UPDATE_FLAGS)) {
                throw new IllegalStateException("Failed to watch childPos");
            }
        }

        this.nodeData.setNodeRequest(nodeId, requestId);
        this.activeNodeRequestCount++;
    }

    //==================================================================================================================
    // Used by the cleaning system to ensure memory capacity in the geometry store
    int markGeometryNull(int nodeId) {
        return 0;
    }

    //Removes, clears and frees itself, all children, requests and everything recursively
    void removeNodeAndChildrenRecursive(int nodeId) {

    }

    //==================================================================================================================
    public boolean writeChanges(GlBuffer nodeBuffer) {
        //TODO: use like compute based copy system or something
        // since microcopies are bad
        if (this.nodeUpdates.isEmpty()) {
            return false;
        }
        for (int i : this.nodeUpdates) {
            this.nodeData.writeNode(UploadStream.INSTANCE.upload(nodeBuffer, i*16L, 16L), i);
        }
        this.nodeUpdates.clear();
        return true;
    }

    private void invalidateNode(int nodeId) {
        this.nodeUpdates.add(nodeId);
    }

    //==================================================================================================================
    private static int getChildIdx(long pos) {
        int x = WorldEngine.getX(pos);
        int y = WorldEngine.getY(pos);
        int z = WorldEngine.getZ(pos);
        return (x&1)|((y&1)<<2)|((z&1)<<1);
    }

    private static long makeChildPos(long basePos, int addin) {
        int lvl = WorldEngine.getLevel(basePos);
        if (lvl == 0) {
            throw new IllegalArgumentException("Cannot create a child lower than lod level 0");
        }
        return WorldEngine.getWorldSectionId(lvl-1,
                (WorldEngine.getX(basePos)<<1)|(addin&1),
                (WorldEngine.getY(basePos)<<1)|((addin>>2)&1),
                (WorldEngine.getZ(basePos)<<1)|((addin>>1)&1));
    }

    public void addDebug(List<String> debug) {
        debug.add("NC/IF: " + this.activeSectionMap.size() + "/" + (this.singleRequests.count() + this.childRequests.count()));
    }
}
