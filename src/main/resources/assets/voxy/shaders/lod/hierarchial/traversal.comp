#version 460 core

//TODO: make this better than a single thread
layout(local_size_x=1, local_size_y=1) in;

#import <voxy:lod/hierarchial/binding_points.glsl>
#line 7

//The queue contains 3 atomics
// end (the current processing pointer)
// head (the current point that is ok to read from)
// top (An atomic that is only used for writing to)
//The way it works when enqueuing
// top is incremented by x,
//   write the data getting enqueued at the starting point specified by the `top` incrmenet
// then increment head strictly _AFTER_ writing to the queue, this ensures that the data is always written and avaible in the queue

layout(binding = SCENE_UNIFORM_INDEX, std140) uniform SceneUniform {
    mat4 VP;
    ivec3 camSecPos;
    uint screenW;
    vec3 camSubSecPos;
    uint screenH;
};

layout(binding = ATOMIC_DATA_INDEX, std430) restrict buffer Atomics {
    uint requestQueueIndex;
    uint requestQueueMaxSize;

    uint renderQueueIndex;
    uint renderQueueMaxSize;
} atomics;

layout(binding = REQUEST_QUEUE_INDEX, std430) restrict writeonly buffer RequestQueue {
    uint[] requestQueue;
};

layout(binding = RENDER_QUEUE_INDEX, std430) restrict writeonly buffer RenderQueue {
    uint[] renderQueue;
};

/*
layout(binding = 2, std430) restrict buffer QueueData {
    uint tail;
    uint head;
    uint top;
    uint[] queue;
} queue;
*/
#line 1
#import <voxy:lod/hierarchial/transform.glsl>
#line 1
#import <voxy:lod/hierarchial/node.glsl>
#line 1

//Contains all the screenspace computation
#import <voxy:lod/hierarchial/screenspace.glsl>
#line 58

//If a request is successfully added to the RequestQueue, must update NodeData to mark that the node has been put into the request queue
// to prevent it from being requested every frame and blocking the queue


//Once a suitable render section is found, it is put into the RenderQueue, or if its not availbe its put into the RequestQueue
// and its children are rendered instead if it has them avalible

//NOTE: EXPERIMENT: INSTEAD OF PERSISTENT THREADS
//TODO: since we know the tree depth is worst case 5, we can just do an indirect dispatch 5 times one for each layer
// issues with this approach, barriers and waiting for one to finish before the otehr can be executed
// advantages, MUCH SIMPLER, no shader barriers needed really , issue is need a flipflip queue but thats ok,
// also ensures the gpu is full of work capacity
// this might be what i do to start with since its much easier to do
// not sure



void addRequest(inout UnpackedNode node) {
    if (!hasRequested(node)) {
        //TODO: maybe try using only 1 variable and it being <0 being bad
        if (atomics.requestQueueIndex < atomics.requestQueueMaxSize) {
            //Mark node as having a request submitted to prevent duplicate submissions
            requestQueue[atomicAdd(atomics.requestQueueIndex, 1)] = getId(node);
            markRequested(node);
        }
    }
}

void enqueueChildren(in UnpackedNode node) {

}

void enqueueSelfForRender(in UnpackedNode node) {
    renderQueue[atomicAdd(atomics.renderQueueIndex, 1)] = getMesh(node);
}

//TODO: need to add an empty mesh, as a parent node might not have anything to render but the children do??
void main() {
    UnpackedNode node;

    //Setup/unpack the node
    unpackNode(node, gl_GlobalInvocationID.x);

    //TODO: check the node is OK first??? maybe?

    //Compute screenspace
    setupScreenspace(node);

    if (isCulledByHiz()) {
        //We are done here, dont do any more, the issue is the shader barriers maybe
        // its culled, maybe just mark it as culled?
    } else {
        //It is visible, TODO: maybe do a more detailed hiz test? (or make it so that )

        if (shouldDecend()) {
            if (hasChildren(node)) {
                enqueueChildren(node);
            } else {
                addRequest(node);
                //TODO: use self mesh (is error state if it doesnt have one since all leaf nodes should have a mesh)
                // Basicly guarenteed to have a mesh, if it doesnt it is very very bad and incorect since its a violation of the graph properties
                // that all leaf nodes must contain a mesh
                enqueueSelfForRender(node);
            }
        } else {
            if (hasMesh(node)) {
                enqueueSelfForRender(node);
            } else {
                //!! not ideal, we want to render this mesh but dont have it. If we havent sent a request
                // then send a request for a mesh for this node.
                addRequest(node);

                //TODO: Decend into children? maybe add a bitflag saying is bad if the immediate children dont have meshes
                enqueueChildren(node);
            }
        }
    }
}


/*
//Thread 0 grabs a batch when empty
void main() {
    while (true) {
        //Each thread processes an entry on the queue and pushes all children to the queue if it is determined the children need to be added
    }
}
*/