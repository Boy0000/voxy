#version 460 core

//TODO: increase local size
#define LOCAL_SIZE_MSK ((1<<LOCAL_SIZE_BITS)-1)
#define LOCAL_SIZE (1<<LOCAL_SIZE_BITS)
layout(local_size_x=LOCAL_SIZE) in;//, local_size_y=1

layout(binding = SCENE_UNIFORM_BINDING, std140) uniform SceneUniform {
    mat4 VP;
    ivec3 camSecPos;
    uint screenW;
    vec3 camSubSecPos;
    uint screenH;
    uint renderQueueMaxSize;
    float minSSS;
};

#import <voxy:lod/hierarchical/queue.glsl>
#import <voxy:lod/hierarchical/node.glsl>
#import <voxy:lod/hierarchical/screenspace.glsl>

SIMPLE_QUEUE(uvec2, requestQueue, REQUEST_QUEUE_BINDING);
SIMPLE_QUEUE(uint, renderQueue, RENDER_QUEUE_BINDING);

void addRequest(inout UnpackedNode node) {
    //printf("Put node decend request");
    if (!hasRequested(node)) {
        if (requestQueueIndex.x < REQUEST_QUEUE_SIZE) {
            uint atomRes = atomicAdd(requestQueueIndex.x, 1);
            if (atomRes < REQUEST_QUEUE_SIZE) {
                //Mark node as having a request submitted to prevent duplicate submissions
                requestQueue[atomRes] = getRawPos(node);
                markRequested(node);
            }
        }
    }
}

void enqueueChildren(in UnpackedNode node) {
    uint children = getChildCount(node);
    pushNodesInit(children);
    uint ptr = getChildPtr(node);
    for (int i = 0; i < children; i++) {
        pushNode(ptr+i);
    }
}

void enqueueSelfForRender(in UnpackedNode node) {
    //printf("render %d@[%d,%d,%d]", node.lodLevel, node.pos.x, node.pos.y, node.pos.z);
    if ((!isEmptyMesh(node)) && renderQueueIndex < renderQueueMaxSize) {
        renderQueue[atomicAdd(renderQueueIndex, 1)] = getMesh(node);
        #ifdef IS_DEBUG
        debugRenderNodeQueue[atomicAdd(debugRenderNodeQueueIndex, 1)] = node.nodeId;
        #endif
    }
}


void traverse(in UnpackedNode node) {
    //Compute screenspace
    setupScreenspace(node);
    //debugDumpNode(node);

    if (outsideFrustum() || isCulledByHiz()) {
        //printf("culled");
    } else {
        //It is visible, TODO: maybe do a more detailed hiz test? (or make it so that )

        //Only decend if not a root node
        if (node.lodLevel!=0 && shouldDecend()) {
            if (hasChildren(node)) {
                //printf("A");
                enqueueChildren(node);
            } else {
                printf("B");
                addRequest(node);
                //TODO: use self mesh (is error state if it doesnt have one since all leaf nodes should have a mesh)
                // Basicly guarenteed to have a mesh, if it doesnt it is very very bad and incorect since its a violation of the graph properties
                // that all leaf nodes must contain a mesh
                enqueueSelfForRender(node);
            }
        } else {
            if (hasMesh(node)) {
                printf("C");
                enqueueSelfForRender(node);
            } else {
                printf("D");
                //!! not ideal, we want to render this mesh but dont have it. If we havent sent a request
                // then send a request for a mesh for this node.
                addRequest(node);

                //TODO: Decend into children? maybe add a bitflag saying is bad if the immediate children dont have meshes
                if (node.lodLevel != 0) {
                    enqueueChildren(node);
                }
            }
        }
    }
}

void main() {
    uint nodeId = getCurrentNode();
    if (nodeId != SENTINAL_OUT_OF_BOUNDS) {
        //Fetch + decode node
        UnpackedNode node;
        unpackNode(node, nodeId);

        traverse(node);

        /*
        printf("GID:%d, NODE %d, %d, AA, %d, %d, %d, %d", gl_GlobalInvocationID.x, node, queueIdx, nodeQueueMetadata[queueIdx].x, nodeQueueMetadata[queueIdx].y, nodeQueueMetadata[queueIdx].z, nodeQueueMetadata[queueIdx].w);
        pushNodesInit(1);
        pushNode(node);
        */
    }
}